[TOC]

# Effective Java Second Edition

## 78条规则

- 第二章：创建和销毁对象，1~7
- 第三章：对于所有对象都通用的方法，8~12 
- 第四章：类和接口，13-22
- 第五章：泛型，23-29
- 第六章：枚举和注解，30-37
- 第七章：方法，38-44
- 第八章：通用程序设计，45-56
- 第九章：异常，57-65
- 第十章：并发，66-73
- 第十一章：序列化，74-78

## 具体规则


1. 考虑用静态工厂方法代替构造器：**切忌第一反应就提供公有的构造器，而不先考虑静态工厂。**
    + 优点：
        * 静态工厂方法与构造器不同的第一大优势在于，它们有名称。具有适当名称的静态工厂会更容易使用，产生的客户端代码也更易于阅读。
        * 第二大优势在于，不必在每次调用它们的时候都创建一个新对象。
        * 第三大优势在于，它们可以返回原返回类型的任何子类型的对象。
        * 第四大优势在于，在创建参数化类型的时候，它们使代码变得更加简洁。
    + 缺点：
        * 类如果不含公有的或者受保护的构造器，就不能被子类化。
        * 它们与其他的静态方法实际上没有任何区别。
2. 遇到多个构造器参数时要考虑使用构建器（Builder Pattern）。
3. 用私有构造器或者枚举类型强化Singleton属性：**单元素枚举类型是实现Singleton的最佳方法。**
4. 通过私有构造器强化不可实例化的能力。
5. 避免创建不必要的对象：**优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。**
6. 消除过期的对象引用。
7. 避免使用终结方法：**终结方法通常是不可预测的，也是很危险的，一般情况下是不必要的。**
8. 覆盖equals时请遵守通用约定。
    + 自反性：对于任何非null的引++用值x，x.equals(x)必须返回true。
    + 对称性：对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。
    + 传递性：对于任何非null引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也必须返回true。
    + 一致性：对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false。
    + 对于任何非null引用值x，x.equals(null)必须返回false。
9. 覆盖equals时总要覆盖hashCode，hashCode约定：
    + 在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个证书。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。
    + 如果两个 对象根据equals(Object)方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。
    + 如果两个对象根据equals(Object)方法比较是不想等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生不同的整数结果。但是程序员应该知道，给不想等的对象产生截然不同的整数结果，有可能提高散列表的性能。
10. 始终要覆盖toString：**toString的通用约定指出，被返回的字符串应该是一个简洁的，但信息量丰富并且易于阅读的表达形式。**
11. 谨慎地覆盖clone。
12. 考虑实现Comparable接口。
13. 使类和成员的可访问性最小化。
14. 在共有类中使用访问方法而非公有域。
15. 使可变性最小化。使类成为不可变类要遵循以下5条规则：
    1. 不要提供任何会修改对象状态的方法。
    2. 保证类不会被扩展。
    3. 使所有的域都是final的。
    4. 使所有的域都成为私有的。
    5. 确保对于任何可变组件的互斥访问。
16. 复合优先于继承。
17. 要么为继承而设计，并提供文档说明，要么就禁止继承。
18. 接口优于抽象类。
19. 接口只用于定义类型。
20. 类层次优于标签类。
21. 用函数对象表示策略。
22. 优先考虑静态成员类。
23. 请不要在新代码中使用原生态类型。
24. 消除非受检警告。
25. 列表优先于数组。
26. 优先考虑泛型。
27. 优先考虑泛型方法。
28. 利用有限制通配符来提升API的灵活性。
29. 优先考虑类型安全的异构容器。
30. 用enum代替int常量。
31. 用实例域代替序数。
32. 用EnumSet代替位域。
33. 用EnumMap代替序数索引。
34. 用接口模拟可伸缩的枚举。
35. 注解优先于命名模式。
36. 坚持使用Override注解。
37. 用标记接口定义类型。
38. 检查参数的有效性。
39. 必要时进行保护性拷贝。
40. 谨慎设计方法签名。
    1. 谨慎地选择方法的名称。
    2. 不要过于追求提供便利的方法。
    3. 避免过长的参数列表。
    4. 参数类型优先使用接口而不是类。
    5. boolean参数，要优先使用两个元素的枚举类型。
41. 慎用重载。
42. 慎用可变参数。
43. 返回零长度的数组或集合，而不是null。
44. 为所有导出的API元素编写文档注释。
45. 将局部变量的作用域最小化。
46. for-each循环优先于传统for循环。
47. 了解和使用类库。
48. 如果需要精确的答案，请避免使用float和double。
49. 基本类型优先于装箱基本类型。
50. 如果其他类型更适合，则尽量避免使用字符串。
51. 当心字符串连接的性能。
52. 通过接口引用对象。
53. 接口优先于反射机制。
54. 谨慎使用本地方法。
55. 谨慎地进行优化。
56. 遵守普遍接受的命名惯例。
57. 只针对异常的情况才使用异常。
58. 对可恢复的情况使用受检异常，对编程错误使用运行时异常。
59. 避免不必要地使用受检异常。
60. 优先使用标准异常。
61. 抛出与抽象相对应的异常。
62. 每个方法抛出异常都要有文档。
63. 在细节消息中包含能捕获失败的信息。
64. 努力使失败保持原子性。
65. 不要忽略异常。
66. 同步访问共享的可变数据。
67. 避免过度同步。
68. executor和Task优先于线程。
69. 并发工具优先于wait和notify。
70. 线程安全性的文档化。
71. 慎用延迟初始化。
72. 不要依赖于线程调度器。
73. 避免使用线程组。
74. 谨慎地实现Serializable接口。
75. 考虑使用自定义的序列化形式。
76. 保护性地编写readObject()方法。
77. 对于实例控制，枚举类型优先于readResovle。
78. 考虑用序列化代理代替序列化实例。
